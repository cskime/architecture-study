# Paradigm Overview

> Clean Architecture 2부 3~6장

패러다임(paradigm)은 정해준 구조, 규칙에 맞게 실행되며 임의로 벗어날 수 없게 만드는 것. 즉, 각 패러다임은 프로그래머에게서 권한을 박탈한다. 프로그래머가 어떤 것을 하면 안되는지를 말해준다.

- 구조적 프로그래밍 : `go to`문을 사용한 제어 흐름의 직접적인 전환을 금지
- 객체 지향 프로그래밍 : 다형성을 interface(protocol)로 구현하여 함수 포인터 사용을 금지
- 함수형 프로그래밍 : 동시성 문제를 유발하는 가변 변수의 할당문 사용을 금지

`go to`문, 함수 포인터, 할당문 등 더 이상 프로그래머에게서 가져갈 요소가 없기 떄문에, 이 패러다임들이 만들어진 후 10년이 넘도록 새로운 패러다임은 나타나지 않았고 앞으로도 그럴 것이다.

## 구조적 프로그래밍

> 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대한 규칙을 부과한다.

- 데이크스트라(Edsger Wybee Dijkstra)가 무분별한 점프(`go to`문)가 프로그램 구조에 해롭다는 것을 발견하고, `if/then/else`와 `do/while/until`같은 익숙한 구조로 대체
    - `go to`문을 사용해서 임의의 위치로 무분별하게 이동하는 것은 코드가 올바르다는 사실을 증명할 때 사용하는 '분할 정복 접근법'을 사용할 수 없게 만든다.
    - `go to`문을 무분별하게 사용하면 예상치 못한 동작을 하므로 올바른 코드임을 증명할 수 없다.
    - `go to`문은 **분기(`if-else`)와 반복(`do/while`)** 에서만 사용하는 것이 좋음
- 모든 프로그램은 **순차**, **분기**, **반복** 세 가지 구조만으로 표현할 수 있다.
- 현대의 프로그램이 언어들은 `go to` 문법을 없애거나 사용 범위를 현재 함수 안으로 제한하는 등 기능을 축소하고 있음

### 기능적 분해

- `go to`를 사용하지 않음으로써 구조적 프로그래밍이 시작되었고, 이로 인해 증명 가능한 작은 단위로 모듈을 분리하고 이 모듈을 기능적으로 분해할 수 있게 됨
- **구조적 분석**이나 **구조적 설계**와 같은 기법이 사용되기 시작
- 대규모 시스템을 **모듈**과 **컴포넌트**로 나눌 수 있다.

### 테스트

- 프로그램의 세세한 기능을 엄밀하게 증명하기보다, '과학'에서의 증명 방법을 적용
- 과학은 서술된 내용이 사실임을 증명하는게 아닌 서술이 틀렸음을 증명함으로써 참임을 증명한다.
    - 즉, **어떤 방법으로도 거짓임을 증명할 수 없다면 목표에 부합할 만큼은 참으로 본다.**
    - **올바르지 않음을 증명하는데 실패함으로써 올바름을 보여준다.**
- **테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.**
- 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해 주는 것이 전부다.
- `go to`문을 남발하면 예측 불가능하기 때문에 프로그램 증명이 불가능해지고, 이러한 프로그램은 테스트를 아무리 많이 수행하더라도 절대로 올바르다고 할 수 없다.

**아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들어야 한다.**

## 객체 지향 프로그래밍

> 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

- 함수 호출 스택 프레임을 힙으로 옮기면 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견
    - 이것이 클래스의 '**생성자**'가 됨
    - 힙에서 오랫동안 유지되는 데이터들은 '**클래스 멤버**'가 됨
- 함수 포인터를 특정한 규칙에 의해 사용하도록 만들며 '**다형성**' 등장

### 캡슐화

- 객체 지향 언어는 캡슐화를 쉽고 효과적으로 할 수 있는 방법을 제공한다.
- 하지만, 캡슐화는 객체 지향 언어가 아닌 C 언어에서도 완벽하게 구현할 수 있다.
    ```c
    // point.h
    /* 외부에서는 Point 타입과 함수만 노출될 뿐, Point의 멤버 변수는 알 수 없다. */
    struct Point;
    struct Point* makePoint(double x, double y);
    double distance (struct Point *p1, struct Point *p2);

    // point.c
    #include "point.h."
    #include <stdlib.h>
    #include <math.h>

    struct Point {
        double x, y;
    }

    struct Point* makePoint(double x, double y) {
        struct Point* p = malloc(sizeof(struct Point));
        p->x = x;
        p->y = y;
        return p;
    }

    double distance(struct Point* p1, struct Point* p2) {
        double dx = p1->x - p2->x;
        double dy = p1->y - p2->y;
        return sqrt(dx*dx+dy*dy);
    }
    ```
- 오히려 객체 지향 개념은 C에서 가능했던 완벽한 은닉화를 약화시켰다.
    - 객체 지향 개념이 들어간 C++은 `private` 멤버 변수로 외부로부터 데이터를 은닉할 수는 있지만, 사용자는 해당 변수가 존재한다는 사실 자체를 알게 된다.
    - 멤버 변수가 변경되면 사용자는 헤더파일을 수정해야 한다. 즉, 어떤 변수(데이터)가 변경되었는지 알 수 있으므로 은닉화가 깨졌다.
    - C#, Java, Swift 등 현대 언어들은 헤더와 구현체를 분리하는 방식을 모두 버림으로써 캡슐화의 개념은 더욱 약해졌다.
- 즉, **캡슐화는 객체 지향의 특성이라고 말하기 어렵다. 오히려 캡슐화를 버리고 있다.**

### 상속

- C 언어에서도 상속을 구현할 수는 있었다.
- 단, 객체 지향 언어에서는 상속을 더 편리한 방법으로 제공한다.
- 즉, **객체 지향 언어는 상속을 더 편하게 구현할 수 있는 방법을 제공하지만, 상속이 객체 지향의 특성이라고 말하기는 어렵다.**

### 다형성

- C 언어에서도 '**함수 포인터**'를 사용해서 다형성을 구현할 수 있었다.
    ```c
    /* 입출력 드라이버의 다섯 가지 함수를 가리키는 함수 포인터를 정의한다.
        1. 열기 (open)
        2. 닫기 (close)
        3. 읽기 (read)
        4. 쓰기 (write)
        5. 탐색 (seek)
     */
    struct File {
        void (*open)(char* name, int mode);
        void (*close)();
        int (*read)();
        void (*write)(char);
        void (*seek)(long index, int mode);
    }
    
    /* STDIN을 FILE*로 선언한 뒤 read 함수를 호출하면, 
        단순히 FILE 데이터 구조의 read 포인터가 가리키는 함수를 호출하는 것과 같다.
     */
    extern struct FILE* STDIN;

    int getchar() {
        return STDIN->read();
    }

    void copy() {
        int c;
        while ((c=getchar()) != EOF)
            putchar(c);
    }
    ```
- 즉, 다형성이란 "**행위가 구체적인 구현체가 아닌 타입에 의존**"하는 기법이다. 이런 기법은 **함수 포인터**를 응용해서 구현할 수 있었다.
    - 행위 : read
    - 타입 : FILE
- 하지만, 함수 포인터를 사용하는 것은 위험할 수 있다. 함수 포인터를 초기화하는 관례를 지키지 않으면 버그가 발생하기 쉽고 고치기도 어렵다.
- 객체 지향 언어는 **다형성을 안전하고 편리하게 사용할 수 있는 방법**을 제공한다.

### 다형성과 플러그인 아키텍처

- 다형성은 '플러그인 아키텍처'를 적용할 때 사용되었다.
    - 플러그인 아키텍처는 입출력 장치의 독립성을 지원하기 위해 사용되었다.
    - 프로그램의 소스코드가 입출력 드라이버 소스코드에 의존하지 않고, 단순히 정의된 함수들을 사용하기만 하면 입출력 드라이버마다 구현해 놓은 코드를 실행시킨다.
    - 즉, "**갈아끼울 수**" 있다.
- 함수 포인터를 사용했을 때는 위험성을 수반하기 때문에 플러그인 아키텍처를 적용하기가 어려웠다.
- 객체 지향 개념이 등장한 뒤로 플러그인 아키텍처를 쉽고 안전하게 구현할 수 있게 되었다.
- 객체 지향 언어에서는 인터페이스(interface) 또는 프로토콜(protocol)을 사용해서 다형성을 구현한다.
    ```swift
    protocol InputOutputDevice {
        func read()
    }

    class SomeInputOutputDriver: InputOutputDevice {
        func read() {
            /* ... */
        }
    }

    let driver: InputOutputDevice = SomeInputOutputDriver()
    driver.read()   // protocol에 정의된 read 함수를 호출하기만 하면
                    // driver에 구현된 코드가 실행된다.
    ```

### 의존성 역전

- 소스코드의 의존성은 항상 제어 흐름을 따르게 된다. 즉, **고수준 함수를 호출하려면 고수준 함수가 포함된 모듈의 소스코드를 import** 해야 한다.

    <img src="img/source-code-dependency-vs-control-flow.png" width="50%">

- 다형성을 사용하면 **소스 코드의 의존성을 역전**시킬 수 있다. 즉, **소스코드 의존성을 원하는 방향으로 마음대로 변경**할 수 있게 된다. 이것을 "**의존성 역전**" 기법이라고 한다.

    <img src="img/dependency-inversion.png" width="50%">

- 프로그래머가 의존성 방향을 마음대로 결정할 수 있게 되면, 업무 규칙(business rule)이 세부사항(UI, DB 등)에 의존하지 않도록 독립적으로 구현할 수 있게 된다. 즉, UI와 DB가 업무 규칙에 **플러그인**이 된다.

    <img src="img/business-rules-dependency.png" width="60%">

- 이렇게 업무 규칙과 세부 사항을 독립적으로 분리하게 되면, UI나 DB에서 발생한 변경사항은 업무 규칙에는 전혀 영향을 줄 수 없게 된다.
    - UI, DB, 업무 규칙 모듈을 독립적으로 배포할 수 있다 -> "**배포 독립성**"
    - 각 모듈들을 서로 다른 팀원들이 나누어서 개발할 수 있다 -> "**개발 독립성**"

## 함수형 프로그래밍

> 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

- 수학의 '람다 계산법'의 영향을 받아 만들어진 패러다임
- '**불변성**' 특징을 가짐. 프로그래밍에서는 변수의 값을 변경하는 '**할당문이 없다**'는 의미
- 할당문이 없거나, 굉장히 까다로운 조건 아래에서만 변수 할당을 허용한다.

### 불변성과 아키텍처

- 경합(race) 조건, 교착상태(deadlock), 동시 업데이트 등 동시성 관련 문제들은 모두 '**가변 변수**' 때문에 발생한다.
- 이상적으로, 저장 공간과 컴퓨팅 성능이 무한하다고 가정하면 완벽하게 불변성을 구현할 수 있다.
- 하지만, 현실적으로 어렵기 때문에 '타협'을 해야 한다.
    - 가변 컴포넌트와 불변 컴포넌트를 분리한다.
    - 불변 컴포넌트에서는 순수 함수형으로만 작업이 처리된다.
    - 가변 컴포넌트에서만 가변 변수를 사용해서 상태를 변경할 수 있다.
    - **불변 컴포넌트는 변수 상태를 변경할 수 있는 가변 컴포넌트와 통신한다.**
- 함수형 패러다임에서 애플리케이션을 제대로 구조화하려면, 불변 컴포넌트와 가변 컴포넌트를 분리하고 **가능한 많은 코드를 불변 컴포넌트로 옮겨야 한다**.

### 이벤트 소싱

- 상태가 아닌 **트랜잭션 자체를 저장**하는 전략
- 모든 트랜잭션을 저장해 두고, 상태가 필요해지면 시작부터 모든 트랜잭션을 단순히 더한다.
- CRUD가 아닌 CR만 수행하므로 **변경과 삭제가 일어나지 않아** 동시 업데이트 문제도 해결된다.
- 애플리케이션의 수명 주기 동안에 **충분한 저장 공간과 처리 능력**만 있으면 구현할 수 있다.
    - Git 같은 버전 관리 시스템이 정확히 이런 방식으로 동작한다.

## 요약

- 구조적 프로그래밍
    - 무분별한 `go to`문의 사용을 막고 순차, 분기, 반복에서만 허용하여 프로그램을 구조적으로 분해할 수 있도록 한다. 
    - 즉, **제어흐름의 직접적인 전환에 대한 규칙을 부과한다.**
- 객체 지향 프로그래밍
    - 다형성을 쉽고 안전하게 구현할 수 있는 방법을 제공함으로써 소스 코드의 의존 방향을 프로그래머 마음대로 변경할 수 있게 하여 모듈의 개발 및 배포 독립성을 확보하고 플러그인 아키텍처를 쉽고 안전하게 구현할 수 있게 돕는다.
    - 즉, **제어흐름의 간접적인 전환에 대한 규칙을 부과한다.**
- 함수형 프로그래밍
    - 가변 변수를 변경할 수 있는 컴포넌트(가변 컴포넌트)와 변경할 수 없는 컴포넌트(불변 컴포넌트)를 분리하고 상태를 변경하는 코드를 최소화하여 경합, 교착, 동시 업데이트 등 동시성 프로그래밍에서 발생할 수 있는 문제들을 해결한다.
    - 즉, **할당문에 대해 규칙을 부과한다.**